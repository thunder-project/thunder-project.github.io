
.. \_factorization\_tutorial:

.. currentmodule:: thunder

Factorization
=============

Factorization algorithms are useful for data-driven decomposition of
spatio-temporal data, for example, to recover spatial patterns with
similar temporal profiles. Here, we show how to use some of the
factorization algorithms in Thunder and visualize the results.

PCA
---

We start by performing PCA (principal component analysis), which finds
patterns that capture most of the variance in the data.

.. code:: python

    # load example data, and cache it to speed up repeated queries
    rawdata = tsc.loadExample('fish-series')
    data = rawdata.normalize()
    data.cache()
    data.dims;
Run PCA with three components

.. code:: python

    from thunder import PCA
    model = PCA(k=2).fit(data)
Fitting PCA adds two attributes to ``model``: ``comps``, which are the
principal components, and ``scores``, which are the data represented in
principal component space. In this case, the input data were
space-by-time, so the components are temporal basis functions, and the
scores are spatial basis functions. Look at the results first by
plotting the components, the temporal basis functions

.. code:: python

    %matplotlib inline
.. code:: python

    import matplotlib.pyplot as plt
    import seaborn as sns
    sns.set_context('notebook')
.. code:: python

    sns.set_style('darkgrid')
    plt.plot(model.comps.T);


.. image:: factorization_files/factorization_10_0.png


The scores are spatial basis functions. We can pack them into a local
array and look at them as images one by one.

.. code:: python

    # dimensions should be (k, x, y, z)
    # where k is the number of components and x, y, z are spatial dimensions
    imgs = model.scores.pack()
    imgs.shape



.. parsed-literal::

    (2, 76, 87, 2)



.. code:: python

    sns.set_style('white')
    plt.imshow(imgs[0,:,:,0], clim=(-0.05,0.05));


.. image:: factorization_files/factorization_13_0.png


.. code:: python

    plt.imshow(imgs[1,:,:,0], clim=(-0.05,0.05));


.. image:: factorization_files/factorization_14_0.png


Clearly there is some spatial structure to each component, but looking
at them one by one can be difficult. A useful trick is to look at two
components at once via a color code that converts the scores into polar
coordinates. The color (hue) shows the relative amount of the two
components, and the brightness shows the total amplitude.

.. code:: python

    from thunder import Colorize
    maps = Colorize(totype='polar', scale=20).images(imgs, )
.. code:: python

    from numpy import amax
    sns.set_style('white')
    plt.imshow(amax(maps,2));


.. image:: factorization_files/factorization_17_0.png


To get more intuition for these colors, we can get the scores from a
random subset of pixels. This will return two numbers per pixel, the
projection onto the first and second principal component, and we
threshold based on the norm so we are sure to retrieve pixels with at
least some structure. Then we make a scatter plot of the two quantities
against one another, using the same colormap as used to generate the
map.

.. code:: python

    pts = model.scores.subset(500, thresh=0.01, stat='norm')
.. code:: python

    sns.set_style('darkgrid')
    clrs = Colorize(totype='polar', scale=50).points(pts[:,0:2])
    plt.scatter(pts[:,0],pts[:,1], c=clrs, s=75, alpha=0.7);


.. image:: factorization_files/factorization_20_0.png


Recall that each of these points represents a single pixel. Another way
to better understand the PCA space is to plot the time series
corresponding to each of these pixels, reconstructed using the first two
principal components.

.. code:: python

    from numpy import asarray
    recon = asarray(map(lambda x: (x[0] * model.comps[0, :] + x[1] * model.comps[1, :]).tolist(), pts))
    plt.gca().set_color_cycle(clrs)
    plt.plot(recon.T);


.. image:: factorization_files/factorization_22_0.png


NMF
---

Non-negative matrix factorization is an alternative decomposition. It is
meant to be applied to data that are strictly positive, which is often
approximately true of neural responses. Like PCA, it also returns a set
of temporal and spatial basis functions, but unlike PCA, it tends to
return basis functions that do not mix responses from different regions
together. We can run NMF on the same data and look at the basis
functions it recovers.

.. code:: python

    from thunder import NMF
    model = NMF(k=3, maxiter=20).fit(data)
After fitting, ``model`` will have two attributes, ``h`` and ``w``. For
these data, ``h`` contains the temporal basis functions, and ``w``
containsthe spatial basis functions. Let's look at both.

.. code:: python

    sns.set_style('darkgrid')
    plt.plot(model.h.T);


.. image:: factorization_files/factorization_26_0.png


.. code:: python

    imgs = model.w.pack()
.. code:: python

    sns.set_style('white')
    plt.imshow(imgs[0][:,:,0], cmap='gray');


.. image:: factorization_files/factorization_28_0.png


.. code:: python

    plt.imshow(imgs[1][:,:,0], cmap='gray');


.. image:: factorization_files/factorization_29_0.png


.. code:: python

    plt.imshow(imgs[2][:,:,0], cmap='gray');


.. image:: factorization_files/factorization_30_0.png


For NMF, a useful way to look at the basis functions is to encode each
one as a separate color channel. We can do that using colorization with
an ``rgb`` conversion, which simply maps the spatial basis functions
directly to red, green, and blue values, and applies a global scaling
factor which controls overall brightness.

.. code:: python

    maps = Colorize(totype='rgb', scale=0.5).images(imgs)
    plt.imshow(maps[:,:,0,:]);


.. image:: factorization_files/factorization_32_0.png


One problem with this way to look at NMF components is that the scale of
the different components can cause some to dominante others. We also
might like more control over color assignments. The ``indexed``
colorization option lets you specify one color per channel, and
automatically normalizes the amplitude of each one.

.. code:: python

    maps = Colorize(totype='indexed', colors=[ "hotpink", "cornflowerblue", "mediumseagreen"], scale=2).images(imgs)
    plt.imshow(maps[:,:,0,:]);


.. image:: factorization_files/factorization_34_0.png


With these plots, it can be useful to add in a background image (for
example, the mean flouresence of each pixel). In this case, we also show
how to select and colorize just two of the three image channels.

.. code:: python

    reference = rawdata.seriesMean().pack()
.. code:: python

    maps = Colorize(totype='indexed', colors=['red', 'blue'], scale=1).images(imgs[[0,2]], background=reference)
    plt.imshow(maps[:,:,0,:]);


.. image:: factorization_files/factorization_37_0.png


ICA
---

Independent component analysis is a final factorization approach. Unlike
NMF, it does not require non-negative signals, but whereas PCA finds
basis functions that maximize explained variance, ICA finds basis
functions that maximize the non-Gaussianity of the recovered signals,
and in practice, they tend to be both more distinct as well as spatially
sparse.

.. code:: python

    from thunder import ICA
    model = ICA(k=10,c=3).fit(data)
.. code:: python

    sns.set_style('darkgrid')
    plt.plot(model.a);


.. image:: factorization_files/factorization_40_0.png


In some cases, some signals will positive and others negative. This is
expected because sign is arbitrary, and it is useful to look at absolute
value when making maps.

.. code:: python

    imgs = model.sigs.pack()
.. code:: python

    maps = Colorize(totype='indexed', colors=['red','green', 'blue'], scale=3).images(abs(imgs))
    sns.set_style('white')
    plt.imshow(maps[:,:,0,:]);


.. image:: factorization_files/factorization_43_0.png

