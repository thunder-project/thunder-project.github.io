
.. \_images\_tutorial:

.. currentmodule:: thunder

Images
======

An ``Images`` object is a distributed collection of either 2d images or
3d volumes. It supports several simple manipulations of image content,
exporting image data, and conversion to other data formats.

Loading images
--------------

Images can be loaded from a ``ThunderContext`` using the ``loadImages``
method. See the ``Input Formats`` tutorial for more detail; here, we'll
just load example image data.

.. code:: python

    data = tsc.loadExample('fish-images')
We can check the number of volumes, and the dimensions:

.. code:: python

    data.nimages



.. parsed-literal::

    20



.. code:: python

    data.dims.max



.. parsed-literal::

    (75, 86, 1)



.. code:: python

    data.dims.min



.. parsed-literal::

    (0, 0, 0)



.. code:: python

    data.dims.count



.. parsed-literal::

    (76, 87, 2)



We can also look at the first record, which is a key-value pair. The
first entry, the key, is an integer identifier (this is the first image,
so it is 0).

.. code:: python

    data.first()[0]



.. parsed-literal::

    0



In Images data, a single record usually corresponds to a single input
file. The ordering of keys comes from sorting the names of the input
files alphabetically. In the common case where a single image file
represents a single time point in an imaging experiment, ordering file
names so that alphabetically later names correspond to later time points
(for instance, by appending a postfix '\_tp000', '\_tp001', etc to a
common file name) will cause the resulting Images data to be sorted in
temporal order. This will greatly ease conversion into
temporally-oriented ``Series`` data and other analyses.

The value of an Images record is the image volume, as an n-dimensional
numpy array:

.. code:: python

    img = data.first()[1]
    img.shape



.. parsed-literal::

    (76, 87, 2)



We can look at it as an image. It's three-dimensional, with two z-planes
to look at:

.. code:: python

    %matplotlib inline
.. code:: python

    import matplotlib.pyplot as plt
    import seaborn as sns
    sns.set_style('white')
    sns.set_context('notebook')
    plt.imshow(img[:,:,0], cmap='gray');


.. image:: images_files/images_16_0.png


Here's the second plane:

.. code:: python

    plt.imshow(img[:,:,1], cmap='gray');


.. image:: images_files/images_18_0.png


Image manipulations
-------------------

An ``Images`` object has a variety of methods for image manipulation.

A common manipulation on volumetric data is computing a maximum
projection in depth. We can perform a maximum projection in parallel
across all volumes. Here, we compute the projections, and then show the
first one.

.. code:: python

    projs = data.maxProjection(axis=2)
    img = projs.first()[1]
    plt.imshow(img, cmap='gray');


.. image:: images_files/images_21_0.png


We can also subselect a set of planes, specifying the top and bottom of
the desired range:

.. code:: python

    sub = data.planes(0,0)
    img = sub.first()[1]
    plt.imshow(img, cmap='gray');


.. image:: images_files/images_23_0.png


And we can subsample in space:

.. code:: python

    sub = data.subsample([5,5,1])
    img = sub.first()[1]
    plt.imshow(img[:,:,0], cmap='gray');


.. image:: images_files/images_25_0.png


Finally, we can perform operations that aggregate across images. For
example, computing the standard deviation:

.. code:: python

    img = data.stdev()
    plt.imshow(img[:,:,0], cmap='gray');


.. image:: images_files/images_27_0.png


The result of distributed image operations can be saved by exporting
each image to a ``png`` file. (NOTE: This support is currently limited
to saving 2d image data.)

.. code:: python

    data.maxProjection().exportAsPngs('directory')
Conversions
-----------

We commonly encounter images or volumes that correspond to different
time points. It is useful to convert these data into a ``Series``
object, the object used in ``thunder`` for distributed array data. After
this conversion, the ``Series`` will be a distributed collection of
records, where each record has a pixel identifier as a key, and a time
series as a value.

There are two ways to convert image or volume data into ``Series`` data.
The first is to load ``Images`` data and then convert it into ``Series``
data. This can be done on an ``Images`` object using the ``toSeries()``
method, and it can also be done in one step using the ``ThunderContext``
method ``loadImagesAsSeries``. Here, we load the example ``Images`` data
and convert it to a ``Series``.

.. code:: python

    data = tsc.loadExample('fish-images')
    ts = data.toSeries()
    ts.cache();
Let's check some properties of the resulting ``Series`` to make sure the
conversion we did makes sense. We have twenty images, so there should be
twenty time points, and the dimensions of the keys should match the
dimensions of the original images.

.. code:: python

    ts.index



.. parsed-literal::

    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
           17, 18, 19])



.. code:: python

    ts.dims.max



.. parsed-literal::

    (75, 86, 1)



.. code:: python

    ts.dims.min



.. parsed-literal::

    (0, 0, 0)



.. code:: python

    ts.dims.count



.. parsed-literal::

    (76, 87, 2)



We can also quickly look at some example time series:

.. code:: python

    samples = ts.normalize().subset(nsamples=50, thresh=0.05)
    sns.set_style('darkgrid')
    plt.plot(samples.T);


.. image:: images_files/images_39_0.png


For a large data set that will be analyzed repeatedly as a ``Series``,
it will ultimately be faster and more convienient to save ``Images``
data to a collection of flat binary files on a distributed file system,
which can in turn be read back in directly as a ``Series``, rather than
repeatedly converting the images to a ``Series`` object. This can be
performed either through a ``ThunderContext`` method,
``convertImagesToSeries``, or directly on an ``Images`` object, as in:

.. code:: python

    data = tsc.loadImages('my-image-directory', inputformat='tif-stack', startidx=0, stopidx=20)
    data.saveAsBinarySeries('my-binary-directory', overwrite=True, )
    ts = tsc.loadSeries('my-binary-directory')